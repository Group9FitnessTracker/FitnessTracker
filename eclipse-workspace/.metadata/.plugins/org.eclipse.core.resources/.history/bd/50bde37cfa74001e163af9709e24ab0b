package linked;


public class DNALinkedList 
{
    private static class Node<T>
    {
        private T					data;
        private Node<T>				prev;	// previous
        private Node<T>				next;
        
        
        Node(T data)
        {
            this.data = data;
        }
        
        // Returns data of prev node, this node, and next node. Uses "<" if prev is
        // null, and ">" if next is null.
        public String toString()
        {
            String s;
            if (prev == null)
                s = "<";
            else s = prev.data.toString();
            
            s += data;
            
            if (next == null)
                s += ">";
            else
                s += next.data;
            
            return s;
        }
        
    }
    
    
    private Node<Character>			head;	// head.prev is always null
    private Node<Character>			tail;	// tail.next is always null
    
    
    public DNALinkedList(String s)
    {
        append(s);
    }
    
    
    // Used by extraction methods. Not for public use.
    private DNALinkedList(Node<Character> head, Node<Character> tail)
    {
        this.head = head;
        head.prev = null;
        this.tail = tail;
        tail.next = null;
    }
    
    
    // Converts arg to nodes which are appended to end of this list.
    public void append(String s)
    {
        for (int i=0; i<s.length(); i++)
            append(s.charAt(i));
    }
    
    
    // Creates a node for ch and appends it to the linked list.
    // "Append" always means "at the end".
    public void append(char ch)
    {
        append(new Node<Character>(ch));
    }
    
    public String toString()
    {
        String s = "DNALinkedList: ";
        if (head == null)
            s += "Empty";
        else
        {
            Node<Character> n = head;
            while (n != null)
            {
                s += n.data;
                n = n.next;
            }
        }
        return s;
    }
    
    
    // Appends n to tail of this list.
    public void append(Node<Character> n)
    {
        // Corner case: empty list.
        if (tail == null)
        {
            n.prev = null;
            n.next = null;
            head = n;
            tail = n;
        }
        
        // General case.
        else
        {
            //fill this in
        	tail.next = n;
        	n.prev = tail;
        	tail = n;
        }
    }
    
    // Returns true if the nodes starting at startNode match the target string. For example,
    // if the linked list looks like this:
    // (A) —> (B) -> (C) -> (D) -> (E) -> (F)
    // and if startNode is the 2nd node (“B”), then matches(startNode, “BCDE”) should return true.
    private boolean matches(Node<Character> startNode, String target)
    {
    	Node<Character> node = startNode;
    	for(int i = 0;i<target.length();i++) {
    		if(node == null) {
    			return false;
    		}
    		if(node.data != target.charAt(i)) {
    			return false;
    		}
    	}
        return true;
    }
    
    
    // If this list contains a chain of nodes whose data is the target, returns
    // the node at the start of that chain. If the target appears multiple times
    // in this list, returns the first occurrence. If the target is not in this list,
    // returns null.
    public Node<Character> find(String target)
    {
        // Hint: call matches(). A lot.
    	Node<Character> current = head;
    	while(current!=null) {
    		if(matches(current,target)) {
    			return current;
    		}
    		current = current.next;
    	}
        return null;
        
    }
    
    
    // Extract and return the nodes starting at firstExtractedNode and ending at lastExtractedNode.
    // The returned nodes should be a DNALinkedList. Don’t worry about any corner cases: assume
    // firstExtractedNode and lastExtractedNode are both in the list and are not near the head or tail.
    public DNALinkedList extract(Node<Character> firstExtractedNode, Node<Character> lastExtractedNode)
    {
        // Find nodes just before and just after the chain to be extracted. Assume these
        // aren't null.
        Node<Character> beforeFirst = firstExtractedNode.prev;
        Node<Character> afterLast = lastExtractedNode.next;
        
        // Connect beforeFirst to afterLast.
        beforeFirst.next = afterLast;
        afterLast.prev  = beforeFirst;
        
        // Return a DNALinkedList containing the extracted chain.
        return new DNALinkedList(firstExtractedNode, lastExtractedNode);
    }
    
    // Inserts insertMe into this list, at the node before insertionPoint. Assumes
    // insertionPoint is not the head or tail.
    public void insert(DNALinkedList insertMe, Node<Character> insertionPoint)
    {
        // Find node immediately before insertion point.
        Node<Character> beforeInsertionPoint = insertionPoint.prev;
        
        // Connect node immediately before insertion point to head of insertMe.
        beforeInsertionPoint.next = insertMe.head;
        insertMe.head.prev = beforeInsertionPoint;
        
        // Connect tail of insertMe to insertionPoint node.
        insertMe.tail.next = insertionPoint;
        insertionPoint.prev = insertMe.tail;
    }
    
    
    // Reverses the order of the nodes.
    public void reverse()
    {
        // Swap next and prev of every node. Caution: in your loop, you won't be able
        // to advance n by setting n = n.next(). Why? How should you advance n?
        Node<Character> n = head;
        while (n != null)
        {
        	Node<Character> oldNext = n.next;
        	n.next = n.prev;
        	n.prev = oldNext;
        	n = oldNext;
            //fill this in
        }
        
        // Swap head and tail.
        Node<Character> temp = head;
        head = tail;
        tail = temp;
        //fill this in
    }
    
    
    // Removes sequence matching transposon, reverses it, and inserts it back into
    // this list immediately before target. Throws IllegalArgumentException if
    // can't find transposon or target. Use the methods you just wrote.
    public void transpose(String transposon, String target) {
        Node<Character> firstNodeOfTransposon = null;
        Node<Character> lastNodeOfTransposon = null;

        // Convert the transposon string into a sequence of nodes
        for (int i = 0; i < transposon.length(); i++) {
            char ch = transposon.charAt(i);
            Node<Character> node = new Node<>(ch);
            if (lastNodeOfTransposon == null) {
                firstNodeOfTransposon = node;
                lastNodeOfTransposon = node;
            } else {
                lastNodeOfTransposon.next = node;
                node.prev = lastNodeOfTransposon;
                lastNodeOfTransposon = node;
            }
        }

        // Find the sequence of nodes in the chromosome that matches the transposon
        Node<Character> current = head;
        while (current != null) {
            if (current.data == firstNodeOfTransposon.data) {
                // Check if the consecutive nodes match the transposon
                Node<Character> chromosomeNode = current;
                Node<Character> transposonNode = firstNodeOfTransposon;
                boolean match = true;
                while (chromosomeNode != null && transposonNode != null) {
                    if (chromosomeNode.data != transposonNode.data) {
                        match = false;
                        break;
                    }
                    chromosomeNode = chromosomeNode.next;
                    transposonNode = transposonNode.next;
                }

                if (match) {
                    // Extract the matching transposon sequence
                    DNALinkedList transposonList = new DNALinkedList(firstNodeOfTransposon, lastNodeOfTransposon);

                    // Remove the original transposon from the chromosome
                    if (chromosomeNode != null) {
                        if (chromosomeNode.prev != null) {
                            chromosomeNode.prev.next = lastNodeOfTransposon.next;
                        }
                        if (lastNodeOfTransposon.next != null) {
                            lastNodeOfTransposon.next.prev = chromosomeNode.prev;
                        }
                    }
                    if (current == head) {
                        head = lastNodeOfTransposon.next;
                    }

                    // Reverse the transposon
                    transposonList.reverse();

                    // Insert the reversed transposon before the target
                    insert(transposonList, current);

                    return;
                }
            }
            current = current.next;
        }

        throw new IllegalArgumentException("Transposon not in the chromosome.");
    }


    
    
    public static void main(String[] args)
    {
        String chromosome = "ATCAGGGGG";
        DNALinkedList list = new DNALinkedList(chromosome);
        System.out.println("original  : " + list);
        String transposon = "TCA";
        String target = "G";
        list.transpose(transposon, target);
        System.out.println("transposed: " + list);
    }
    
}
